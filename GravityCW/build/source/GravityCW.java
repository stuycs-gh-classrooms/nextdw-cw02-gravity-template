/* autogenerated by Processing revision 1286 on 2023-04-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class GravityCW extends PApplet {

float GRAVITY = 0.4f;
int MAX_SIZE  = 50;
int MIN_SIZE = 10;
float MAX_MASS = 10;
float MIN_MASS = 1;

int NUM_ORBS = 10;
Orb[] orbs;
boolean moving;
boolean multiBall;
boolean earthGravity;
boolean orbit;
boolean bounce;
boolean trails;

Orb earth;
Orb centerGravity;

 public void setup() {
  noStroke();
  /* size commented out by preprocessor */;
  background(200);
  orbs = new Orb[NUM_ORBS];
  resetRandom();

  //the earth is far away and massive
  earth = new Orb(width/2, height * 100, 1, 100);

  centerGravity = new Orb(width/2, height/2, 10, 20);
}//setup

 public void draw() {
  if (!trails) {
    background(200);
    stroke(0);
  }
  displayMode();
  if (trails) {
    noStroke();
  }
  for (int i=0; i<orbs.length; i++) {
    orbs[i].display();
  }//show orbs
  if (orbit) {
    centerGravity.display();
  }

  if (moving) {
    for (int i=0; i<orbs.length; i++) {
      if (multiBall) {
        for (int j=0; j<orbs.length; j++) {
          PVector g = orbs[i].getGravity(orbs[j], GRAVITY);
          orbs[i].applyForce(g);
        }
      }//orbs attract each other

      if (earthGravity) {
        PVector g = orbs[i].getGravity(earth, GRAVITY);
        orbs[i].applyForce(g);
      }//orbs pulled down by earth

      if (orbit) {
        PVector g = orbs[i].getGravity(centerGravity, GRAVITY);
        orbs[i].applyForce(g);
      }//orbs pulld toward center

    }//apply gravity

    for (int i=0; i<orbs.length; i++) {
      orbs[i].run(bounce);
    }//run the sumlation
  }

}//draw

 public void pushAll(PVector p) {
  for (int i=0; i<orbs.length; i++) {
    orbs[i].applyForce(p);
  }
}//pushAll

 public void resetRandom() {
  moving = false;
  bounce = false;
  multiBall = true;
  earthGravity = false;
  orbit = false;
  background(200);
  for (int i=0; i<orbs.length; i++) {
    int s = PApplet.parseInt(random(MIN_SIZE, MAX_SIZE));
    float m = random(MIN_MASS, MAX_MASS);
    int x = PApplet.parseInt(random(s, width-s));
    int y = PApplet.parseInt(random(s, height-s));
    orbs[i] = new Orb(x, y, s, m);
  }
}//resetRnadom

 public void resetHorizontal() {
  moving = false;
  bounce = false;
  multiBall = false;
  earthGravity = true;
  orbit = false;
  background(200);
  int x = 10;
  int y = 60;
  for (int i=0; i<orbs.length; i++) {
    int s = PApplet.parseInt(random(MIN_SIZE, MAX_SIZE));
    float m = random(MIN_MASS, MAX_MASS);
    x+= s/2;
    orbs[i] = new Orb(x, y, s, m);
    x+= s/2 + 10;
  }
}//resetHorizontal

 public void resetVertical() {
  moving = false;
  bounce = false;
  earthGravity = false;
  multiBall = false;
  orbit = true;
  background(200);
  int x = width/2;
  int y = 62;
  for (int i=0; i<orbs.length; i++) {
    int s = 16;//int(random(MIN_SIZE, MAX_SIZE));
    float m = random(MIN_MASS, MAX_MASS);
    orbs[i] = new Orb(x, y, s, m);
    y+= 44;

    if (i == orbs.length/2-1) {
      y = height/2 + 40;
    }
  }
}//reset

 public void keyPressed() {
  if (key == ' ') {
    moving = !moving;
  }
  if (key == 'b')  {
    bounce = !bounce;
  }
  if (key == 'm')  {
    multiBall = !multiBall;
  }
  if (key == 'e')  {
    earthGravity = !earthGravity;
  }
  if (key == 'o') {
    orbit = !orbit;
  }
  if (key == 't') {
    trails = !trails;
  }
  if (key == 'r') {
    resetRandom();
  }
  if (key == 'h') {
    resetHorizontal();
  }
  if (key == 'v')  {
    resetVertical();
  }
  if (keyCode == UP) {
    pushAll(new PVector(0, -0.5f));
  }
  if (keyCode == DOWN) {
    pushAll(new PVector(0, 0.5f));
  }
  if (keyCode == LEFT) {
    pushAll(new PVector(-0.5f, 0));
  }
  if (keyCode == RIGHT) {
    pushAll(new PVector(0.5f, 0));
  }
}//keyPressed

 public void displayMode() {
  //initial setup
  int c;
  textAlign(LEFT, TOP);
  textSize(15);
  noStroke();

  //red or green boxes
  c = moving ? color(0, 255, 0) : color(255, 0, 0);
  fill(c);
  rect(0, 0, 53, 20);
  c = bounce ? color(0, 255, 0) : color(255, 0, 0);
  fill(c);
  rect(54, 0, 57, 20);
  c = multiBall ? color(0, 255, 0) : color(255, 0, 0);
  fill(c);
  rect(112, 0, 140, 20);
  c = earthGravity ? color(0, 255, 0) : color(255, 0, 0);
  fill(c);
  rect(253, 0, 100, 20);
  c = orbit ? color(0, 255, 0) : color(255, 0, 0);
  fill(c);
  rect(354, 0, 42, 20);
  stroke(0);
  fill(0);
  text("MOVING", 1, 0);
  text("BOUNCE", 55, 0);
  text("MUTUAL ATTRACTION", 113, 0);
  text("EARTH GRAVITY", 254, 0);
  text("ORBIT", 355, 0);

}
class Orb {

  PVector position;
  PVector velocity;
  PVector acceleration;
  int size;
  float mass;
  int c;

  Orb(int x, int y, int s, float m) {
    position = new PVector(x, y);
    velocity = new PVector(0, 0);
    acceleration = new PVector(0, 0);
    size = s;
    mass = m;
    c = color(random(256), random(256), random(256));
  }//constructor

   public void run(boolean bounce) {
    position.add(velocity);
    velocity.add(acceleration);
    acceleration.mult(0);

    if (bounce) {
      yBounce();
      xBounce();
    }
  }//run

   public PVector getGravity(Orb o, float G) {
    if (o != this) {
      float d = this.position.dist(o.position);
      d = constrain(d, 5, 100);
      float mag = (G * mass * o.mass) / (d * d);
      PVector direction = PVector.sub(o.position, this.position);
      direction.normalize();
      direction.mult(mag);
      return direction;
    }
    return new PVector(0, 0);
  }//getGravity

   public float getDensity() {
    return mass/size;
  }//getDensity

   public void applyForce(PVector f) {
    PVector newf = f.copy();
    newf.div( mass );
    acceleration.add(newf);
  }//applyForce

   public void yBounce() {
    if (position.y < size/2) {
      position.y = size/2;
      velocity.y *= -1;
    }
    else if (position.y >= (height-size/2)) {
      position.y = height - size/2;
      velocity.y *= -1;
    }
  }//yBounce

   public void xBounce() {
    if (position.x < size/2) {
      position.x = size/2;
      velocity.x *= -1;
    }
    else if (position.x >= width - size/2) {
      position.x = width - size/2;
      velocity.x *= -1;
    }
  }//xBounce

   public boolean checkYBoundry() {
    boolean check = position.y >= height - size/2;
    check = check || (position.y <= size/2);
    return check;
  }
   public boolean checkXBoundry() {
    boolean check = position.x >= width - size/2;
    check = check || (position.x <= size/2);
    return check;
  }

   public void display() {
    int t = PApplet.parseInt(map(getDensity(), MIN_MASS/MAX_SIZE, MAX_MASS/MIN_SIZE, 100, 255));
    fill(c, t);
    circle(position.x, position.y, size);
  }//display

}//OrbNode


  public void settings() { size(600, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "GravityCW" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
